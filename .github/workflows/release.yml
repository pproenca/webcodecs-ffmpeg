name: Release

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v0.2.0)'
        required: true
        type: string

permissions:
  contents: write
  id-token: write
  attestations: write
  actions: read

env:
  EXPECTED_ARTIFACTS: >-
    ffmpeg-darwin-arm64-bsd
    ffmpeg-darwin-arm64-lgpl
    ffmpeg-darwin-arm64-gpl
    ffmpeg-darwin-x64-bsd
    ffmpeg-darwin-x64-lgpl
    ffmpeg-darwin-x64-gpl

jobs:
  # Job 1: Resolve tag to commit SHA
  resolve:
    name: resolve-tag
    runs-on: ubuntu-latest
    outputs:
      commit: ${{ steps.resolve.outputs.commit }}
      tag: ${{ steps.resolve.outputs.tag }}
    steps:
      - name: Resolve tag to commit
        id: resolve
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            TAG="${{ github.event.release.tag_name }}"
          else
            TAG="${{ inputs.tag }}"
          fi

          # Handle both lightweight and annotated tags
          RESPONSE=$(gh api "repos/${{ github.repository }}/git/refs/tags/${TAG}" 2>/dev/null || echo "")
          if [[ -z "$RESPONSE" ]]; then
            echo "::error::Could not find tag $TAG"
            exit 1
          fi

          OBJECT_TYPE=$(echo "$RESPONSE" | jq -r '.object.type')
          OBJECT_SHA=$(echo "$RESPONSE" | jq -r '.object.sha')

          # Annotated tags point to a tag object, lightweight tags point directly to commit
          if [[ "$OBJECT_TYPE" == "tag" ]]; then
            # Annotated tag - dereference to get the commit SHA it points to
            COMMIT=$(gh api "repos/${{ github.repository }}/git/tags/${OBJECT_SHA}" --jq '.object.sha')
          else
            # Lightweight tag - SHA is already the commit
            COMMIT="$OBJECT_SHA"
          fi

          echo "Resolved tag $TAG to commit $COMMIT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

  # Job 2: Check for existing CI artifacts
  check-artifacts:
    name: check-artifacts
    needs: resolve
    runs-on: ubuntu-latest
    outputs:
      found: ${{ steps.search.outputs.found }}
      run_id: ${{ steps.search.outputs.run_id }}
    steps:
      - name: Search for CI artifacts
        id: search
        env:
          GH_TOKEN: ${{ github.token }}
          COMMIT: ${{ needs.resolve.outputs.commit }}
        run: |
          echo "Searching for CI artifacts at commit $COMMIT"

          # Find successful CI workflow run for this commit
          RUN_ID=$(gh api "repos/${{ github.repository }}/actions/workflows/ci.yml/runs" \
            --jq ".workflow_runs[] | select(.head_sha == \"$COMMIT\" and .conclusion == \"success\") | .id" \
            2>/dev/null | head -1 || echo "")

          if [[ -z "$RUN_ID" ]]; then
            echo "No successful CI run found for commit $COMMIT"
            echo "found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found CI run: $RUN_ID"

          # Verify all expected artifacts exist
          ARTIFACTS=$(gh api "repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
            --jq '.artifacts[].name' 2>/dev/null || echo "")

          MISSING=""
          for name in $EXPECTED_ARTIFACTS; do
            if ! echo "$ARTIFACTS" | grep -q "^${name}$"; then
              MISSING="$MISSING $name"
            fi
          done

          if [[ -n "$MISSING" ]]; then
            echo "Missing artifacts:$MISSING"
            echo "found=false" >> "$GITHUB_OUTPUT"
          else
            echo "All 6 artifacts found in CI run $RUN_ID"
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
          fi

  # Job 3: Build only if CI artifacts not found
  build:
    name: build
    needs: [resolve, check-artifacts]
    if: needs.check-artifacts.outputs.found != 'true'
    uses: ./.github/workflows/_build.yml
    with:
      ref: ${{ needs.resolve.outputs.commit }}
      retention-days: 90
    permissions:
      contents: read
      id-token: write
      attestations: write

  # Job 4: Publish to GitHub Release and npm
  publish:
    name: publish
    needs: [resolve, check-artifacts, build]
    if: always() && !cancelled() && needs.resolve.result == 'success' && needs.check-artifacts.result == 'success' && (needs.build.result == 'success' || needs.build.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download from CI workflow
        if: needs.check-artifacts.outputs.found == 'true'
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ needs.check-artifacts.outputs.run_id }}
          path: artifacts-download

      - name: Download from fallback build
        if: needs.check-artifacts.outputs.found != 'true'
        uses: actions/download-artifact@v4
        with:
          path: artifacts-download
          merge-multiple: true

      - name: Flatten artifact directories
        run: |
          # dawidd6/action-download-artifact creates subdirectories per artifact
          # Flatten them to match expected structure
          cd artifacts-download
          for dir in */; do
            if [[ -d "$dir" ]]; then
              mv "$dir"* . 2>/dev/null || true
              rmdir "$dir" 2>/dev/null || true
            fi
          done
          echo "Flattened artifacts:"
          ls -la

      - name: Verify all artifacts present
        run: |
          cd artifacts-download
          EXPECTED=6  # 2 platforms Ã— 3 licenses
          shopt -s nullglob
          tarballs=(./*.tar.gz)
          ACTUAL=${#tarballs[@]}

          if [[ "$ACTUAL" -ne "$EXPECTED" ]]; then
            echo "::error::Expected $EXPECTED tarballs, found $ACTUAL"
            ls -la
            exit 1
          fi
          echo "All $EXPECTED artifacts present"

      - name: Verify checksums
        run: |
          cd artifacts-download
          shopt -s nullglob
          files=(*.sha256)

          if [[ ${#files[@]} -eq 0 ]]; then
            echo "::error::No checksum files found"
            exit 1
          fi

          echo "Verifying ${#files[@]} checksums..."
          for f in "${files[@]}"; do
            TARBALL="${f%.sha256}"
            if [[ ! -f "$TARBALL" ]]; then
              echo "::error::Missing tarball for $f"
              exit 1
            fi
            echo "Verifying $f..."
            sha256sum --check "$f"
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Extract artifacts
        run: |
          mkdir -p artifacts

          for tarball in artifacts-download/*.tar.gz; do
            echo "Extracting $tarball..."
            tar -xzvf "$tarball" -C artifacts

            # Verify expected directory was created
            # Tarball is named ffmpeg-<platform>-<license>.tar.gz but contains
            # directory <platform>-<license>/ (no ffmpeg- prefix) to match
            # Makefile artifact structure and populate-npm.sh expectations
            DIRNAME=$(basename "$tarball" .tar.gz)
            DIRNAME="${DIRNAME#ffmpeg-}"
            if [[ ! -d "artifacts/$DIRNAME" ]]; then
              echo "::error::Extraction failed - artifacts/$DIRNAME not found"
              exit 1
            fi
          done

          echo "Extracted artifacts:"
          ls -la artifacts/

      - name: Generate artifact attestations
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: 'artifacts-download/*.tar.gz'

      - name: Populate npm packages
        env:
          FFMPEG_VERSION: ${{ needs.resolve.outputs.tag }}
        run: |
          # Strip 'v' prefix from tag (v0.1.0 -> 0.1.0)
          export FFMPEG_VERSION="${FFMPEG_VERSION#v}"
          ./scripts/populate-npm.sh

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release upload "${{ needs.resolve.outputs.tag }}" \
            artifacts-download/*.tar.gz \
            artifacts-download/*.sha256 --clobber

      - name: Publish to npm
        working-directory: npm
        run: npm publish --workspaces --access public --provenance
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
