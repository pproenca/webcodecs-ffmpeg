name: Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      tag:
        description: 'Re-release existing tag (leave empty for new release)'
        required: false
        type: string

permissions:
  contents: write
  id-token: write
  attestations: write
  actions: read

env:
  EXPECTED_ARTIFACTS: >-
    ffmpeg-darwin-arm64-bsd
    ffmpeg-darwin-arm64-lgpl
    ffmpeg-darwin-arm64-gpl
    ffmpeg-darwin-x64-bsd
    ffmpeg-darwin-x64-lgpl
    ffmpeg-darwin-x64-gpl

jobs:
  # Job 1: Calculate version and resolve commit
  prepare:
    name: prepare-release
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.version.outputs.tag }}
      commit: ${{ steps.version.outputs.commit }}
      is_new_release: ${{ steps.version.outputs.is_new_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for tags

      - name: Calculate version
        id: version
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ -n "${{ inputs.tag }}" ]]; then
            # Re-releasing existing tag
            TAG="${{ inputs.tag }}"
            echo "is_new_release=false" >> "$GITHUB_OUTPUT"

            # Resolve tag to commit SHA
            RESPONSE=$(gh api "repos/${{ github.repository }}/git/refs/tags/${TAG}" 2>/dev/null || echo "")
            if [[ -z "$RESPONSE" ]]; then
              echo "::error::Could not find tag $TAG"
              exit 1
            fi

            OBJECT_TYPE=$(echo "$RESPONSE" | jq -r '.object.type')
            OBJECT_SHA=$(echo "$RESPONSE" | jq -r '.object.sha')

            if [[ "$OBJECT_TYPE" == "tag" ]]; then
              COMMIT=$(gh api "repos/${{ github.repository }}/git/tags/${OBJECT_SHA}" --jq '.object.sha')
            else
              COMMIT="$OBJECT_SHA"
            fi
          else
            # Calculate new version from bump_type
            CURRENT=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
            IFS='.' read -r MAJ MIN PAT <<< "$CURRENT"

            case "${{ inputs.bump_type }}" in
              major) MAJ=$((MAJ + 1)); MIN=0; PAT=0 ;;
              minor) MIN=$((MIN + 1)); PAT=0 ;;
              patch) PAT=$((PAT + 1)) ;;
            esac

            TAG="v${MAJ}.${MIN}.${PAT}"
            COMMIT=$(git rev-parse HEAD)
            echo "is_new_release=true" >> "$GITHUB_OUTPUT"
          fi

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"
          echo "Releasing $TAG at commit $COMMIT"

  # Job 2: Wait for CI workflow to complete (if still running)
  wait-for-ci:
    name: wait-for-ci
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Wait for CI workflow
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ needs.prepare.outputs.commit }}
          repo-token: ${{ github.token }}
          check-regexp: '^build \(.*\)$'
          wait-interval: 30
          allowed-conclusions: success

  # Job 3: Check for existing CI artifacts (REQUIRED - no fallback build)
  check-artifacts:
    name: check-artifacts
    needs: [prepare, wait-for-ci]
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.search.outputs.run_id }}
    steps:
      - name: Search for CI artifacts
        id: search
        env:
          GH_TOKEN: ${{ github.token }}
          COMMIT: ${{ needs.prepare.outputs.commit }}
        run: |
          echo "Searching for CI artifacts at commit $COMMIT"

          # Find successful CI workflow run for this commit
          RUN_ID=$(gh api "repos/${{ github.repository }}/actions/workflows/ci.yml/runs" \
            --jq ".workflow_runs[] | select(.head_sha == \"$COMMIT\" and .conclusion == \"success\") | .id" \
            2>/dev/null | head -1 || echo "")

          if [[ -z "$RUN_ID" ]]; then
            echo "::error::No successful CI run found for commit $COMMIT"
            echo "::error::Push to master first and wait for CI to complete before releasing."
            exit 1
          fi

          echo "Found CI run: $RUN_ID"

          # Verify all expected artifacts exist
          ARTIFACTS=$(gh api "repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts" \
            --jq '.artifacts[].name' 2>/dev/null || echo "")

          MISSING=""
          for name in $EXPECTED_ARTIFACTS; do
            if ! echo "$ARTIFACTS" | grep -q "^${name}$"; then
              MISSING="$MISSING $name"
            fi
          done

          if [[ -n "$MISSING" ]]; then
            echo "::error::Missing artifacts:$MISSING"
            echo "::error::CI artifacts may have expired. Re-run CI workflow first."
            exit 1
          fi

          echo "All 6 artifacts found in CI run $RUN_ID"
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"

  # Job 4: Create tag, GitHub Release, and publish to npm
  publish:
    name: publish
    needs: [prepare, check-artifacts]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create and push tag
        if: needs.prepare.outputs.is_new_release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ needs.prepare.outputs.tag }}"
          COMMIT="${{ needs.prepare.outputs.commit }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag "$TAG" "$COMMIT"
          git push origin "$TAG"

          echo "Created and pushed tag $TAG"

      - name: Create GitHub Release
        if: needs.prepare.outputs.is_new_release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release create "${{ needs.prepare.outputs.tag }}" \
            --generate-notes \
            --target "${{ needs.prepare.outputs.commit }}"

      - name: Download from CI workflow
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: ci.yml
          run_id: ${{ needs.check-artifacts.outputs.run_id }}
          path: artifacts-download

      - name: Flatten artifact directories
        run: |
          # dawidd6/action-download-artifact creates subdirectories per artifact
          # Flatten them to match expected structure
          cd artifacts-download
          for dir in */; do
            if [[ -d "$dir" ]]; then
              mv "$dir"* . 2>/dev/null || true
              rmdir "$dir" 2>/dev/null || true
            fi
          done
          echo "Flattened artifacts:"
          ls -la

      - name: Verify all artifacts present
        run: |
          cd artifacts-download
          EXPECTED=6  # 2 platforms Ã— 3 licenses
          shopt -s nullglob
          tarballs=(./*.tar.gz)
          ACTUAL=${#tarballs[@]}

          if [[ "$ACTUAL" -ne "$EXPECTED" ]]; then
            echo "::error::Expected $EXPECTED tarballs, found $ACTUAL"
            ls -la
            exit 1
          fi
          echo "All $EXPECTED artifacts present"

      - name: Verify checksums
        run: |
          cd artifacts-download
          shopt -s nullglob
          files=(*.sha256)

          if [[ ${#files[@]} -eq 0 ]]; then
            echo "::error::No checksum files found"
            exit 1
          fi

          echo "Verifying ${#files[@]} checksums..."
          for f in "${files[@]}"; do
            TARBALL="${f%.sha256}"
            if [[ ! -f "$TARBALL" ]]; then
              echo "::error::Missing tarball for $f"
              exit 1
            fi
            echo "Verifying $f..."
            sha256sum --check "$f"
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Extract artifacts
        run: |
          mkdir -p artifacts

          for tarball in artifacts-download/*.tar.gz; do
            echo "Extracting $tarball..."
            tar -xzvf "$tarball" -C artifacts

            # Verify expected directory was created
            # Tarball is named ffmpeg-<platform>-<license>.tar.gz but contains
            # directory <platform>-<license>/ (no ffmpeg- prefix) to match
            # Makefile artifact structure and populate-npm.sh expectations
            DIRNAME=$(basename "$tarball" .tar.gz)
            DIRNAME="${DIRNAME#ffmpeg-}"
            if [[ ! -d "artifacts/$DIRNAME" ]]; then
              echo "::error::Extraction failed - artifacts/$DIRNAME not found"
              exit 1
            fi
          done

          echo "Extracted artifacts:"
          ls -la artifacts/

      - name: Generate artifact attestations
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: 'artifacts-download/*.tar.gz'

      - name: Populate npm packages
        env:
          FFMPEG_VERSION: ${{ needs.prepare.outputs.tag }}
        run: |
          # Strip 'v' prefix from tag (v0.1.0 -> 0.1.0)
          export FFMPEG_VERSION="${FFMPEG_VERSION#v}"
          ./scripts/populate-npm.sh

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release upload "${{ needs.prepare.outputs.tag }}" \
            artifacts-download/*.tar.gz \
            artifacts-download/*.sha256 --clobber

      - name: Publish to npm (sequential to avoid E409)
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          cd npm

          # Publish sequentially to avoid npm registry race condition (E409)
          # Platform packages first (dependencies for meta packages)
          for pkg in darwin-arm64 darwin-arm64-lgpl darwin-arm64-gpl \
                     darwin-x64 darwin-x64-lgpl darwin-x64-gpl; do
            echo "Publishing $pkg..."
            npm publish -w "$pkg" --access public --provenance
            sleep 2  # Let registry process before next publish
          done

          # Dev package (headers only, independent)
          echo "Publishing dev..."
          npm publish -w dev --access public --provenance
          sleep 2

          # Meta packages last (have optionalDependencies on platform packages)
          for pkg in ffmpeg ffmpeg-lgpl ffmpeg-gpl; do
            echo "Publishing $pkg..."
            npm publish -w "$pkg" --access public --provenance
            sleep 2
          done

          echo "All packages published successfully"
